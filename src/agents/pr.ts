import type { GitHubIssue, MiyabiConfig } from '../types/index.js';
import { GitHubClient } from '../lib/github-client.js';
import { execSync } from 'child_process';

export interface PRResult {
  success: boolean;
  prNumber?: number;
  prUrl?: string;
  error?: string;
}

export class PRAgent {
  private github: GitHubClient;

  constructor(config: MiyabiConfig) {
    this.github = new GitHubClient(
      config.github.token,
      config.github.owner,
      config.github.repo
    );
  }

  async execute(
    issue: GitHubIssue,
    branchName: string,
    qualityScore: number,
    filesGenerated: string[]
  ): Promise<PRResult> {
    try {
      await this.github.createComment(
        issue.number,
        'ü§ñ **PRAgent Started**\n\n' +
          `Creating Draft PR with Conventional Commits...\n\n` +
          `**Branch:** \`${branchName}\``
      );

      // Step 1: Push branch to remote
      await this.pushBranch(branchName);

      // Step 2: Create PR title and body
      const prTitle = this.generatePRTitle(issue);
      const prBody = this.generatePRBody(issue, qualityScore, filesGenerated);

      // Step 3: Create Draft PR using gh CLI
      const prUrl = await this.createDraftPR(branchName, prTitle, prBody);

      // Step 4: Extract PR number from URL
      const prNumber = this.extractPRNumber(prUrl);

      // Step 5: Link PR to Issue
      await this.github.createComment(
        issue.number,
        `‚úÖ **PRAgent Completed**\n\n` +
          `Draft PR created: ${prUrl}\n\n` +
          `**Next Steps:**\n` +
          `1. Review the generated code\n` +
          `2. Run tests locally if needed\n` +
          `3. Approve and merge when ready\n\n` +
          `Closes #${issue.number}`
      );

      return {
        success: true,
        prNumber,
        prUrl,
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      await this.github.createComment(
        issue.number,
        `‚ùå **PRAgent Failed**\n\n\`\`\`\n${errorMessage}\n\`\`\``
      );

      return {
        success: false,
        error: errorMessage,
      };
    }
  }

  private async pushBranch(branchName: string): Promise<void> {
    try {
      execSync(`git push -u origin ${branchName}`, { stdio: 'pipe' });
    } catch (error) {
      // Branch might already be pushed, try without -u
      try {
        execSync(`git push origin ${branchName}`, { stdio: 'pipe' });
      } catch (retryError) {
        throw new Error(`Failed to push branch ${branchName}`);
      }
    }
  }

  private generatePRTitle(issue: GitHubIssue): string {
    // Conventional Commits format
    const type = this.determineCommitType(issue);
    return `${type}: ${issue.title}`;
  }

  private determineCommitType(issue: GitHubIssue): string {
    const labels = issue.labels.map((l) => l.name.toLowerCase());

    if (labels.some((l) => l.includes('bug'))) return 'fix';
    if (labels.some((l) => l.includes('feature'))) return 'feat';
    if (labels.some((l) => l.includes('refactor'))) return 'refactor';
    if (labels.some((l) => l.includes('docs'))) return 'docs';
    if (labels.some((l) => l.includes('test'))) return 'test';
    if (labels.some((l) => l.includes('chore'))) return 'chore';

    return 'feat'; // Default
  }

  private generatePRBody(
    issue: GitHubIssue,
    qualityScore: number,
    filesGenerated: string[]
  ): string {
    let body = `## Summary\n\n`;
    body += `This PR implements the changes requested in #${issue.number}.\n\n`;

    if (issue.body) {
      body += `### Issue Description\n\n${issue.body}\n\n`;
    }

    body += `## Generated Files\n\n`;
    for (const file of filesGenerated) {
      body += `- \`${file}\`\n`;
    }

    body += `\n## Quality Score\n\n`;
    body += `**Score:** ${qualityScore}/100 ${qualityScore >= 80 ? '‚úÖ' : '‚ùå'}\n\n`;

    body += `## Test Plan\n\n`;
    body += `- [ ] Code compiles without errors\n`;
    body += `- [ ] All tests pass\n`;
    body += `- [ ] Code follows project conventions\n`;
    body += `- [ ] No security vulnerabilities introduced\n\n`;

    body += `## Checklist\n\n`;
    body += `- [x] Code generated by AI (CodeGenAgent)\n`;
    body += `- [x] Quality review completed (ReviewAgent)\n`;
    body += `- [ ] Manual review by human\n`;
    body += `- [ ] Ready to merge\n\n`;

    body += `---\n\n`;
    body += `ü§ñ Generated with [Claude Code](https://claude.com/claude-code)\n\n`;
    body += `Closes #${issue.number}`;

    return body;
  }

  private async createDraftPR(
    branchName: string,
    title: string,
    body: string
  ): Promise<string> {
    // Escape quotes in title and body for shell
    const escapedTitle = title.replace(/"/g, '\\"');
    const escapedBody = body.replace(/"/g, '\\"').replace(/\n/g, '\\n');

    try {
      const output = execSync(
        `gh pr create --draft --base main --head ${branchName} --title "${escapedTitle}" --body "${escapedBody}"`,
        { stdio: 'pipe', encoding: 'utf-8' }
      );

      // gh pr create returns the PR URL
      return output.trim();
    } catch (error: any) {
      const stderr = error.stderr || error.message || '';
      if (stderr.includes('already exists')) {
        // PR already exists, get the URL
        const output = execSync(`gh pr view ${branchName} --json url -q .url`, {
          stdio: 'pipe',
          encoding: 'utf-8',
        });
        return output.trim();
      }
      throw error;
    }
  }

  private extractPRNumber(prUrl: string): number {
    // Extract PR number from URL like https://github.com/owner/repo/pull/123
    const match = prUrl.match(/\/pull\/(\d+)/);
    if (!match || !match[1]) {
      throw new Error(`Failed to extract PR number from URL: ${prUrl}`);
    }
    return parseInt(match[1], 10);
  }
}
